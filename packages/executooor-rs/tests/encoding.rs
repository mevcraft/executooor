use alloy_primitives::hex;
use alloy_primitives::{address, Address, Bytes, U256};
use executooor::encoder::{encode_callback_data, EncodedExec, ExecutorEncoder};
use executooor::types::CallbackContext;

const DAI: Address = address!("6B175474E89094C44Da98b954EedeAC495271d0F");
const WETH: Address = address!("C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
const BALANCER_VAULT: Address = address!("BA12222222228d8Ba445958a75a0704d566BF2C8");
const AAVE_V2_POOL: Address = address!("7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9");
const EXECUTOR: Address = address!("1111111111111111111111111111111111111111");

/// Helper: hex string to Bytes (strips leading "0x" if present).
fn h(s: &str) -> Bytes {
    let s = s.strip_prefix("0x").unwrap_or(s);
    Bytes::from(hex::decode(s).unwrap())
}

fn h_vec(s: &str) -> Vec<u8> {
    let s = s.strip_prefix("0x").unwrap_or(s);
    hex::decode(s).unwrap()
}

// ============================================================
// 1. build_call â€” no context, no placeholders
// ============================================================
#[test]
fn test_build_call_no_context() {
    // ERC20 approve(aaveV2Pool, 1_000_000)
    let result = ExecutorEncoder::build_erc20_approve(DAI, AAVE_V2_POOL, U256::from(1_000_000u64));

    let expected = h("0x000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a900000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000");
    assert_eq!(result, expected);
}

// ============================================================
// 2. Context encoding (dataIndex=3, sender=balancerVault)
// ============================================================
#[test]
fn test_build_call_with_context() {
    let ctx = CallbackContext {
        sender: BALANCER_VAULT,
        data_index: 3,
    };
    let result =
        ExecutorEncoder::build_call(BALANCER_VAULT, U256::ZERO, Bytes::new(), Some(&ctx), vec![]);

    let expected = h("0x00000000000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c80000000000000000000000000000000000000000000000000000000000000000000000000000000000000003ba12222222228d8ba445958a75a0704d566bf2c800000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(result, expected);
}

// ============================================================
// 3. build_erc20_approve
// ============================================================
#[test]
fn test_build_erc20_approve() {
    let result = ExecutorEncoder::build_erc20_approve(DAI, AAVE_V2_POOL, U256::from(500u64));

    let expected = h("0x000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a900000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000");
    assert_eq!(result, expected);
}

// ============================================================
// 4. build_erc20_transfer
// ============================================================
#[test]
fn test_build_erc20_transfer() {
    let result = ExecutorEncoder::build_erc20_transfer(DAI, BALANCER_VAULT, U256::from(1000u64));

    let expected = h("0x000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000");
    assert_eq!(result, expected);
}

// ============================================================
// 5. encode_exec (two calls batched)
// ============================================================
#[test]
fn test_encode_exec() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.erc20_approve(DAI, AAVE_V2_POOL, U256::from(500u64));
    encoder.erc20_transfer(DAI, BALANCER_VAULT, U256::from(1000u64));

    let EncodedExec { to, data, value } = encoder.encode_exec(U256::ZERO);

    assert_eq!(to, EXECUTOR);
    assert_eq!(value, U256::ZERO);

    let expected = h("0x0000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a900000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c800000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(data, expected);
}

// ============================================================
// 6. encode_callback_data
// ============================================================
#[test]
fn test_encode_callback_data() {
    let call1 = ExecutorEncoder::build_erc20_approve(DAI, AAVE_V2_POOL, U256::from(500u64));
    let result = encode_callback_data(vec![call1], Bytes::new());

    let expected = h("0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000104000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a900000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(result, expected);
}

// ============================================================
// 7. erc20_balance_of placeholder
// ============================================================
#[test]
fn test_erc20_balance_of() {
    let encoder = ExecutorEncoder::new(EXECUTOR);
    let placeholder = encoder.erc20_balance_of(DAI, EXECUTOR, 36);

    assert_eq!(placeholder.to, DAI);
    assert_eq!(placeholder.offset, 36);
    assert_eq!(placeholder.length, 32);
    assert_eq!(placeholder.resOffset, 0);

    let expected_data =
        h("0x70a082310000000000000000000000001111111111111111111111111111111111111111");
    assert_eq!(placeholder.data, expected_data);
}

// ============================================================
// 8. erc20_skim (call with placeholder)
// ============================================================
#[test]
fn test_erc20_skim() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.erc20_skim(DAI, EXECUTOR);
    let calls = encoder.flush();
    assert_eq!(calls.len(), 1);

    let expected = h("0x000000020000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000044a9059cbb0000000000000000000000001111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002470a08231000000000000000000000000111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000");
    assert_eq!(calls[0], expected);
}

// ============================================================
// 9. wrap_eth
// ============================================================
#[test]
fn test_wrap_eth() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.wrap_eth(WETH, U256::from(1_000_000u64));
    let calls = encoder.flush();
    assert_eq!(calls.len(), 1);

    let expected = h("0x00000000000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000");
    assert_eq!(calls[0], expected);
}

// ============================================================
// 10. keccak256("ERC3156FlashBorrower.onFlashLoan")
// ============================================================
#[test]
fn test_maker_return_value() {
    let hash = alloy_primitives::keccak256("ERC3156FlashBorrower.onFlashLoan");
    let expected = h_vec("439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9");
    assert_eq!(hash.as_slice(), expected.as_slice());
}

// ============================================================
// 11. transfer via executor
// ============================================================
#[test]
fn test_transfer() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.transfer(DAI, U256::from(500u64));
    let calls = encoder.flush();
    assert_eq!(calls.len(), 1);

    let expected = h("0x0000000000000000000000000000000011111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000");
    assert_eq!(calls[0], expected);
}

// ============================================================
// 12. tip
// ============================================================
#[test]
fn test_tip() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.tip(U256::from(500u64));
    let calls = encoder.flush();
    assert_eq!(calls.len(), 1);

    // The inner calldata should be transfer(address(0), 500)
    let tip_calldata_hex = "a9059cbb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f4";
    // Verify the inner calldata appears in the encoded call
    let call_hex = hex::encode(&calls[0]);
    assert!(call_hex.contains(tip_calldata_hex));
}

// ============================================================
// 13. flush resets state
// ============================================================
#[test]
fn test_flush_resets() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.erc20_approve(DAI, AAVE_V2_POOL, U256::from(100u64));
    encoder.erc20_approve(DAI, AAVE_V2_POOL, U256::from(200u64));

    let calls = encoder.flush();
    assert_eq!(calls.len(), 2);

    let calls_after = encoder.flush();
    assert_eq!(calls_after.len(), 0);
}

// ============================================================
// 14. total_value accumulates with wrap_eth
// ============================================================
#[test]
fn test_total_value_accumulates() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.wrap_eth(WETH, U256::from(100u64));
    encoder.wrap_eth(WETH, U256::from(200u64));

    let EncodedExec { value, .. } = encoder.encode_exec(U256::ZERO);
    assert_eq!(value, U256::from(300u64));
}

// ============================================================
// 15. encode_exec extra_value
// ============================================================
#[test]
fn test_encode_exec_extra_value() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.wrap_eth(WETH, U256::from(100u64));

    let EncodedExec { value, .. } = encoder.encode_exec(U256::from(50u64));
    assert_eq!(value, U256::from(150u64));
}

// ============================================================
// 16. function selectors
// ============================================================
#[test]
fn test_function_selectors() {
    // exec_606BaXt(bytes[]) => 0x00000001
    let exec_call = ExecutorEncoder::build_erc20_approve(DAI, AAVE_V2_POOL, U256::from(1u64));
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder.erc20_approve(DAI, AAVE_V2_POOL, U256::from(1u64));
    let EncodedExec { data, .. } = encoder.encode_exec(U256::ZERO);
    assert_eq!(
        &data[..4],
        &[0x00, 0x00, 0x00, 0x01],
        "exec_606BaXt selector"
    );

    // call_g0oyU7o => 0x00000000
    assert_eq!(
        &exec_call[..4],
        &[0x00, 0x00, 0x00, 0x00],
        "call_g0oyU7o selector"
    );

    // callWithPlaceholders4845164670 => 0x00000002
    let mut encoder2 = ExecutorEncoder::new(EXECUTOR);
    encoder2.erc20_skim(DAI, EXECUTOR);
    let calls = encoder2.flush();
    assert_eq!(
        &calls[0][..4],
        &[0x00, 0x00, 0x00, 0x02],
        "callWithPlaceholders selector"
    );
}

// ============================================================
// 17. chaining pattern
// ============================================================
#[test]
fn test_chaining() {
    let mut encoder = ExecutorEncoder::new(EXECUTOR);
    encoder
        .erc20_approve(DAI, AAVE_V2_POOL, U256::from(100u64))
        .erc20_transfer(DAI, BALANCER_VAULT, U256::from(200u64))
        .wrap_eth(WETH, U256::from(300u64));

    let calls = encoder.flush();
    assert_eq!(calls.len(), 3);
}
